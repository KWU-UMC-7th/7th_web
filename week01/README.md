# 1주차 키워드

## number

더하기
‘+’ 연산자 사용

```jsx
var x = 9 + 7;
```

‘++’(증가) 연산자 사용

```jsx
x++;  // x = x + 1;
```

빼기
‘-’ 연산자 사용

```jsx
var x = 20 - 9;
```

‘--’(감소) 연산자 사용

```jsx
x--;  //x = x - 1;
```

곱하기
‘*’ 연산자 사용

```jsx
var x = 9 * 7;
```

나누기
‘/’ 연산자 사용

```jsx
var x = 9 / 3;
```

나머지
‘%’ 연산자 사용

```jsx
var x = 9 % 2;
```

거듭제곱
‘**’ 연산자 사용

```jsx
var x = 9 ** 2;  //9^2
```

복합대입연산자
```jsx
var a = 9;

a += 1;    //a = a + 1;
a -= 1;    //a = a - 1;
a *= 2;    //a = a * 2;
a /= 2;    //a = a / 2;

```

---
## 일치 불일치

일치
‘===’ 연산자 사용

```jsx
5 === 9 - 4   //T
```

> 수학에서 ‘=’ 기호는 서로 같음을 의미하지만
> JS에서 ‘=’ 기호는 대입을 의미한다
> 따라서 컴퓨터가 명확하게 구분하기 위해 ‘===’ 사용한다.


불일치
‘!==’

```jsx
9 !== 5 + 4   //F
```

> 수학에서 같지 않음을 ‘≠’을 사용한다.
하지만 키보드에 ‘≠’이 할당되지 않았음으로
’!==’를 ‘≠’하자 약속했다.
>


---
## 연산자 우선순위
수학처럼 JS에도 연산자 **우선순위**가 존재.
우선순위가 높을 것 부터 연산이 실행.
(곱셈과 나눗셈을 덧셈과 뺄셈보다 먼저 하는 것 처럼)

1. **괄호                         [ () ]**
2. **증감/논리/not         [ ++, --, &&, ||, ! ]**
3. **산술                         [ +, -, *, / ]
(곱셈 나눗셈 먼저, 덧셈 뺄셈 나중)**
4. **비교 (부등호)           [ <, <=, >, >=]**
5. **비교 (등호)               [ ==, ===, !=, !== ]**
6. **논리                          [ &&, || ]
(and 연산이 먼저, or 연산 나중)**
7. **대입 연산자              [ =, +=, -=, *= , /=, %= ]**


---
## bigint

### bigint (Overflow 피하는 방법)

int 최댓값에 1을 더한다면 오버플로우 발생

bigint를 사용하면 안전하게 범위 제한을 벗어날 수 있음

---
# 객체 타입

## sort
배열을 정렬해서 반환

```jsx
[8,6,1,57,32,9].sort();
//[1,6,8,9,32,57]

['유과', '옥춘당', '매작과', '다식', '강정'].sort();
//['강정', '다식', '매작과', '옥춘당', '유과']
```

<aside>
🔴

주의!

함수가 배열 내의 값을 내부적으로 문자열로 변환시킴

문자 입장에서 ‘-’는 별 의미없는 문자

</aside>

## join
각 요소 사이의 구분자(연결자)를 넣어서 출력할 수 있음
(파이썬의 sep()와 비슷)
    
    ```jsx
    const browsers = ['IE', 'chrome', 'firefox', 'opera', 'naver'];
    
    console.log(browsers.join());
    //IE, chrome, firefox, opera, naver
    //기본은 ',' 출력
    
    console.log(browsers.join(' & '));
    //IE & chrome & firefox & opera & naver
    ```

## revers
    배열 내 값들의 위치를 반전
    
    ```jsx
    const numbers = [1,2,3,4,5,6,7,8,9];
    
    console.log(numbers.revers());
    //[9,8,7,6,5,4,3,2,1]
    ```

## splice    
    배열의 기존 요소를 변경 (삭제 / 교체 / 추가)
    
    ```jsx
    const months = ['Jan', 'March', 'April', 'June'];
    months.splice(1, 0, 'Feb');
    //1번 인덱스 위치에 'Feb' 삽입
    console.log(months);
    //[Jan, Feb, March, April, June]
    
    months.splice(4, 1, 'May');
    //4번 인덱스 위치의 요소 1개를 대체
    console.log(months);
    //[Jan, Feb, March, April, May]
    
    ```

## find
    조건에 맞는 값을 찾아 반환
    (없으면 ‘undefined’ 반환)
    
    반환 값에 따라 함수가 조금씩 다름
    
    ```jsx
    const array = [];
    
    //요소의 인덱스를 반환
    
    //값의 인덱스를 반
    
    //값의 존재 여부를 반환
    ```

## map
    
    각 요소에 대해 함수 호출하고 결과를 모아 새로운 배열 반환
    
    ```jsx
    const origin = [1,2,3,4,5,6];
    const twice = origin.map((x) => x*2);
    //origin의 각 요소를 x로 받아 연산 후 twice에 저장
    
    console.log(twice);
    ```

## every
    
    배열의 모든 요소가 주어진 함수에 대해 참인지 판별
    (AND 게이트의 배열 ver.)